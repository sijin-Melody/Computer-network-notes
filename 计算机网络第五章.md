# 计算机网络第五章

![image-20230326124047320](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326124047320.png)

![image-20230326184104754](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326184104754.png)

接下来我们从计算机网络体系结构的角度来看运输层。这是通信双方应用层中的应用进程。假设AP1与AP 4之间进行基于网络的通信，AP2与AP3之间进行基于网络的通信，在运输层需要不同的端口来对应不同的应用进程，然后通过网络层及其下层来传输应用层报文。如图所示，接收方的运输层通过不同的端口将收到的应用层报文交付给应用层中相应的应用进程。

需要注意的是这里的端口并不是指看得见摸得着的物理端口，而是指用来区分不同应用进程的标识符。为了简单起见，在学习和研究运输层时，我们可以简单的认为，运输层直接为应用进程间的逻辑通信提供服务。逻辑通信的意思是运输层之间的通信好像是沿水平方向传送数据，但事实上这两个运输层之间并没有一条水平方向的物理连接，要传送的数据是沿着涂装上下多次的虚线方向传送的

![image-20230326184114316](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326184114316.png)

小结：

![image-20230326184127455](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326184127455.png)

## 5.2 运输层端口号、复用与分用的概念

复用：就是可以重复使用的意思，即各个应用层协议都可以使用TCP协议；

分用：就是TCP根据端口号，将报文分给不同的应用进程。

![image-20230326185728944](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326185728944.png)

![image-20230326185900703](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326185900703.png)
发送方的某些应用进程所发送的不同应用报文，在**运输层**使用UDP协议进行封装，这称为UDP复用。而另一些应用进程做发送的不同应用报文，在**运输层**使用TCP协议进行封装，这称为TCP复用，**运输层使用端口号来区分不同的应用进程**。不管是使用运输层的UDP协议，封装成的UDP用户数据报，还是使用TCP协议封装成的TCP报文段，在**网络层**都需要使用IP协议封装成IP数据报，这称为IP复用。

![image-20230326190638441](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326190638441.png)

![image-20230326192139249](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326192139249.png)

![image-20230326233811047](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326233811047.png)

接下来我们通过一个实例来进一步说明运输层端口号的作用。如图所示用户PC,DNS服务器，WEB服务器通过交换机进行互联，它们处于同一个以太网中，假设这是WEB服务器的域名，DNS服务器中记录有该域名所对应的IP地址，我们在用户PC中使用网页浏览器来访问WEB服务器的内容，在网页浏览器的地址栏中输入WEB服务器的域名，用户PC中的DNS客户端进程，会发送一个DNS查询请求报文，其内容为域名www.PARTTEST.COM，所对应的IP地址是什么？DNS查询请求报文，需要使用运输层的UDP协议封装成UDP，用户数据报，其首部中的源端口自断值，在短暂端口号49151到65535中挑选一个未被占用的用来表示DNS客户端进程，例如49152。目的端口字段的值设置为53，这是DNS服务器端进程所使用的熟知端口号。**之后将UDP、用户数据报封装在IP数据报中**通过以太网发送给DNS的服务器。 DNS服务器端收到该数据报后，从中解封出UDP用户数据报，UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文交付给本服务器中的DNS服务器端进程，DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址之后，会给用户PC发送DNS响应报文，其内容为域名www.PARTTEST.COM，所对应的IP地址是192.168.0.3。DNS响应报文，需要使用运输层的UDP协议封装成UDP，用户数据报，其首部中的源端口字段的值，设置为熟知端口号53，**表明这是DNS服务器端进程所发送的UDP用户数据报，**目的端口字段的值设置为49152，这是之前用户PC中发送DNS查询请求报文的 DNS客户端进程所使用的短暂端口号。

之后将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC，用户PC收到该数据报后，从中解封出UDP用户数据报，UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，**也就是DNS响应报文交付给用户PC中的DNS客户端进程，DNS客户端进程解析DNS响应报文的内容。就可知道自己之前所请求的WEB服务器的域名所对应的IP地址为192.168.0.3。**

‍现在用户PC中的HTTP客户端进程，可以向WEB服务器发送HTTP请求报文了，其内容为首页内容是什么？HTTP请求报文，需要使用运输层的TCP协议，封装成TCP报文段，其首部中的原端口字段的值在短暂端口号49151到65535中，挑选一个未被占用的用来表示HTTP客户端进程，例如仍然使用之前用过的49152目的端口字段的值设置为80，这是HTTP服务器端进程所使用的熟知端口号。之后将TCP报文段封装在IP数据报中，通过以太网发送给WEB服务器，WEB服务器收到该数据报后，从中解封出TCP报文段，TCP首部中的目的端口号为80，这表明应该将该TCP报文段的数据载荷部分，也就是HTTP请求报文交付给本服务器中的HTTP服务器端进程，HTTP服务器端进程，解析HTTP请求报文的内容，然后按其要求查找首页内容之后，会给用户PC发送HTTP响应报文，其内容是 HTTP客户端所请求的首页内容，HTTP响应报文，需要使用运输层的TCP协议，封装成TCP报文段，其首部中的原端口号字段的值，设置为熟知端口号80，表明这是HTTP服务器端进程所发送的TCP报文段，目的端口字段的值设置为49152，这是之前用户PC中发送HTTP请求报文的HTTP客户端进程所使用的短暂端口号。之后将TCP报文段封装在IP数据报中，通过以太网发送给用户PC，用户收到该数据报后，从中解封出TCP报文段，TCP首部中的目的端口号为49152，这表明应该将该TCP报文段的数据载荷部分，也就是HTTP响应报文，交付给用户PC中的， HTTP客户端进程，解析HTTP响应报文的内容，并在网页浏览器中进行显示，这样我们就可以在网页浏览器中看到WEB服务器所提供的首页内容了，(`面试重点`)

## 5.3 UDP和TCP的对比

![image-20230326233957575](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326233957575.png)
这两个协议的使用频率‍‍仅次于往基层的IP协议

(`面试重点`)

![image-20230326234306867](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326234306867.png)
运输层使用UDP协议进行通信，纵坐标为时间，使用UDP协议的通信双方‍‍可以随时发送数据。
TCP的连接管理。“三报文""四报文”
这里所谓的连接是指逻辑连接关系，‍‍而不是物理连接。‍‍
综上所述，**UDP是无连接的，而TCP是面向连接的。**

![image-20230326234458555](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326234458555.png)
TCP连接建立成功后，通信双方之间‍‍就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信

对比这两个协议对应用报文的处理
![image-20230326234817938](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230326234817938.png)

  UDP协议的情况：发送方的应用进程，‍‍将应用层报文交付给运输层的UDP，UDP直接给应用层报文，添加一个UDP首部，‍‍使之成为UDP用户数据报，然后进行发送。‍‍
   TCP协议的情况：发送方的TCP‍‍把应用进程交付下来的数据块，仅仅看作是一连串的无结构的字节流，‍‍TCP并不知道这些待传送的字节流的含义，仅将他们编号并存储在自己的发送缓存中。‍‍TCP根据发送策略，从发送缓存中提取一定数量的字节，构建TCP报文段并发送‍‍。接收方的TCP，‍‍一方面从所接收到的TCP报文段中取出数据载荷部分，‍‍并存储在接收缓存中，一方面将接收缓存中的一些字节交付给应用进程，‍‍**TCP不保证接收方应用进程所收到的数据块与发送方应用进程和发出的数据块‍‍具有对应大小的关系。**但接收方应用进程收到的字节流‍‍必须和发送方应用进程发出的字节流完全一样。当然接收方的应用进程‍‍必须有能力识别收到的字节流，把它还原成有意义的应用层数据，也就是说‍‍ TCP是面向自字节流的，这正是TCP实现可靠传输，流量控制以及拥塞控制的基础。
（tcp接收数据的时候要建立缓存区解决粘包分包问题）

在实际网络中‍‍基于TCP连接的两端，可以同时进行TCP报文段的发送和接收，‍‍也就是全双工通信。另外图中TCP报文段的数据部分只包含了几个字节，实际当中‍‍一个TCP报文段包含上千个字节是很常见的。‍‍

![image-20230327000014995](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327000014995.png)

对比一下UDP用户数据报的首部与TCP报文段的首部‍‍
![image-20230327000620789](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327000620789.png)
	UDP首部格式如图所示‍‍仅有4个字段，每个字段长度为2个字节。由于UDP不提供可靠传输服务，‍‍它仅仅在网际层的基础上添加了用于区分应用进程的端口，‍‍因此他的首部非常简单，仅有8个字节

​	1个TCP报文段，有首部‍‍和数据载荷两部分构成，其首部格式如图所示，这比UDP用户数据报的首部复杂的多，‍‍其最小长度为20字节，最大长度为60字节，

小结：

![image-20230327000717176](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327000717176.png)

## 5.4流量控制

![image-20230327000815587](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327000815587.png)

### 累计确认的概念

![image-20230327000831837](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327000831837.png)

我们来举例说明，假设主机A和B是因特网上的两台主机，它们之间已经建立了TCP连接，A给B发送数据，B对A进行流量控制，这是主机A中带发送数据的字节序号，假设主机A发送的每个TCP报文段可携带100字节数据，因此图中每个小格子表示100个字节数据的序号，在主机A和B建立TCP连接时，**B告诉A我的接收窗口为400，因此主机A将自己的发送窗口也设置为400，**这意味着主机A在未收到主机B发来的确认时，可将序号落入发送窗口中的全部数据发送出去。

接下来我们举例说明主机B对A的流量控制，主机A将发送窗口内序号1~100的数据，封中成一个TCP报文段发送出去，发送窗口内还有300字节可以发送。这里的seq是TCP报文段首部中的序号字段，取值一，表示TCP报文段数据载荷的第一个字节的序号是一，这里的DATA表示这是TCP数据报文段，主机A将发送窗口内序号101~200的数据，封中成一个TCP报文段发送出去，发送窗口内还有200字节可以发送，主机A将发送窗口内，序号201~300的数据，封中成一个TCP报文段发送出去，但该报文段在传输过程中丢失了，主机A发送窗口内还有100字节可以发送。主机B对主机A所发送的201号以前的数据进行累计确认，并在该累计确认中将窗口字段的值调整为300，也就是对主机A进行流量控制。**这里的大写ACK是TCP报文段首部中的标志位，取值一，表示这是一个TCP确认报文段**，小写**ack是TCP报文段首部中的确认号字段，取值201，表示序号201之前的数据已全部正确接收**，现在希望收到序号201及其后续数据。

**RWND是TCP报文段首部中的窗口字段，取值300，表示自己的接收窗口大小为300。**主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号，移出发送窗口。

![image-20230327001358958](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327001358958.png)

**由于主机B在该累计确认中，将自己的接收窗口调整为了300，因此主机A相应的将自己的发送窗口调整为300**。目前主机A发送窗口内的序号为201~500，也就是主机A还可以发送这300字节，其中201~300号字节是已发送的数据，若重传计时器超时，他们会被重传。301号到400号字节，以及401号到500号字节还未被发送，可被分别封中在一个TCP报文段中发送。主机A现在**可将发送缓存中序号1~200的字节数据全部删除了，因为已经收到了主机B对他们的累计确认**。

主机A将发送窗口内序号301~400个数据，封中成一个TCP报文段发送出去，发送窗口内还有100字节可以发送，主机A将发送窗口内序号401~500的数据，封中成一个TCP报文段发送出去，至此序号落在发送窗口内的数据已经全部发送出去了，不能再发送新数据了。
现在发送窗口内序号201~300，这100个字节数据的重传计时器超时了，主机A将它们重新封中成一个TCP报文段发送出去，暂时不能发送其他数据。

主机B收到该重传的TCP报文段后，对主机A所发送的501号以前的数据进行累计确认，并在该累计确认中将窗口字段的值调整为100。这是主机B对主机A进行的第二次流量控制。

![image-20230327001409221](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327001409221.png)

主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号，移出发送窗口。由于主机B在该累计确认中将自己的接收窗口调整为了100，因此主机A相应的将自己的发送窗口调整为100。目前主机A发动窗口内的序号为501~600，也就是主机A还可以发送这100字节，主机A现在可将发送缓存中序号201~500的字节数据全部删除了，因为已经收到了主机B对他们的**累积确认**，主机A将发送窗口内序号501~600的数据，封中成一个TCP报文段发送出去，**至此序号落在发送窗口内的数据已经全部发送出去了，不能再发送新数据了**。主机B对主机A所发送的601号以前的数据进行累计确认，并在该领域确认中将窗口字段的值调整为0。这是主机B对主机A进行的第三次流量控制。

![image-20230327001416344](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327001416344.png)

主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号，移出发送窗口。由于主机B在该累计确认中将自己的接收窗口调整为了0，因此主机A相应的将自己的发送窗口调整为0。目前主机A不能再发送一般的TCP报文段了，主机A现在可将发送缓存中序号501~600的字节数据全部删除了，因为已经收到了主机币被他们的累计确认，**假设主机B向主机A发送了0窗口的报文段后不久，主机B的接收缓存又有了一些存储空间**，于是主机B向主机A发送了接收窗口等于300的报文段，然而这个报文段在传输过程中丢失了，主机A一直等待主机B发送的非0窗口的通知，而主机B也一直等待主机A发送的数据，如果不采取措施，这种互相等待而形成的**死锁局面**将一直持续下去。**为了解决这个问题，TCP为每一个连接设有一个持续计时器，**只要TCP连接的一方，收到对方的0窗口通知，就要起到持续计时器。若持续计时器超时，就要发送一个0窗口探测报文，仅携带一字节的数据，而对方在确认这个探测报文段时，给出自己现在的接收窗口值。如果接收窗口仍然是0，那么收到报文段的一方要重新启动持续计时器，如果接收窗口不是0，那么死锁的局面就可以被打破了。

![image-20230327233217494](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327233217494.png)

在本例中，主机A收到零窗口通知时，就要启动一个**持续计时器**，当持续计时器超时，主机A立刻发送一个仅携带一字节数据的**零窗口探测报文段**，假设主机B此时的接收窗口又为0了，主机B就在确认零窗口探测报文段时，给出自己现在的接收窗口值为零。主机A再次收到零窗口通知，就要再次启动一个持续计时器，当持续计时器超时，主机A立刻发送一个零窗口探测报文段，假设主机B此时的接收缓存又有了一些存储空间，于是将自己的接收窗口调整为了300，主**机B就在确认零窗口探测报文段时，给出自己现在的接收窗口值为300，这样就打破了死锁的局面。**

主机A所发送的零窗口探测报文段到达主机B时，如果主机B此时的接收窗口仍然为0，那么主机B根本就无法接受该报文段，又怎么会针对该报文段给主机A发回确认呢？实际上TCP规定即使接收窗口为0，也必须接受零窗口探测报文段，确认报文段，以及携带有紧急数据的报文段。

请大家再来思考一下这个问题。如果零窗口探测报文段丢失了，会出现怎样的问题呢？还能否打破死锁的局面呢？回答是肯定的，因为零窗口探测报文段也有重传计时器，当重传计时器超时后，零窗口探测报文段会被重传。

习题：

![image-20230327233537410](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327233537410.png)

根据题意可知，主机甲的发动窗口为4000字节，主机甲向主机乙连续发送两个最大段，共2000字节，也就是将发送窗口内，序号0~1999的字节数据发送出去，主机乙给主机甲发送针对第一个段的确认，并在该确认中给出自己当前的接收窗口大小为2000字节，主机甲收到该确认后，将发送窗口向前滑动，使已发送并收到确认的第一个段的序号移出发送窗口。由于主机乙在确认中给出的自己的接收窗口大小为2000字节，因此主机甲相应的将自己的发送窗口调整为2000字节，很显然主机甲还可以向主机乙发送2000~2999号字节数据，共1000个字节，

小结：

![image-20230327233641622](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327233641622.png)

## 5.5TCP的拥塞控制

![image-20230327233906743](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327233906743.png)

TCP的4种拥塞控制算法：
![image-20230327234511381](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327234511381.png)

假设这是TCP的发送方和接收方，发送方给接收方发送TCP数据报文段，接收方收到后给发送方发送TCP确认报文段
![image-20230327234553174](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327234553174.png)

首先来看慢开始算法:
横坐标为传输轮次，传输轮次是指发送方给接收方发送数据报文段后，接收方给发送方发回相应的确认报文段。**一个传输轮次所经历的时间，其实就是往返时间。**请注意往返时间并非是恒定的数值，使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个报文段的确认。
纵坐标是拥塞窗口，它会随网络拥塞程度以及所使用的拥塞控制算法动态变化。

在TCP双方建立逻辑连接关系时，拥塞窗口的值被设置为1，我们在图上标出传输轮次0时的拥塞窗口值为一，另外还需设置慢开始门线的初始值，本例采用16。**当拥塞窗口值增长到慢开始门限值时，就要改为执行拥塞避免算法。**

由于发送方当前的拥塞窗口值是1，而发送窗口值等于拥塞窗口值，因此发送方当前只能发送一个TCP数据报文段，换句话说，拥塞窗口值是几，就能发送几个数据报文段，如图所示发送方发送0号数据报文段，接收方收到后给发送方发回对0号报文段的确认报文段，发送方收到该确认报文段后，将拥塞窗口值加一增大到二，我们在图中标出该值，这意味着发送方现在可以发送1~2号共两个数据报文段，接收方收到后给发送方发回，对1~2号报文段的确认报文段。

……

拥塞窗口值加8增大到16，增大到了慢开始门限值之后，改用拥塞避免算法，也就是每个传输轮次结束后，拥塞窗口值只能线性加一，而不像慢开始算法那样，每个传输轮次结束后，拥塞窗口值按指数规律增长

超时重传。
![image-20230327235316293](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327235316293.png)

![image-20230327235335076](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327235335076.png)

最终呈现图：
![image-20230327235558424](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327235558424.png)

![image-20230327235631783](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327235631783.png)
当拥塞窗口值增大到24时，发生了超时重传，而网络此时并没有发生拥塞，但是发送方却误认为网络发生了拥塞，于是发送方把拥塞窗口值减小为一并错误的启动慢开始算法，因而降低了传输效率。

![image-20230327235749749](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230327235749749.png)

我们来举例说明快重传算法：

- 发送方发送1号数据报文段，接收方收到后给发送方发回，对1号报文段的确认，在该确认报文段到达发送方之前，发送方还可以将发送窗口内的2号数据报文段发送出去，
- 接收方收到后给发送方发回对2号报文段的确认。
- 在该确认报文段到达发送方之前，发送方还可以将发送窗口内的3号数据报文段发送出去，但该报文段丢失了，接收方自然不会给发送方发回针对该报文段的确认，
- 发送方还可以将发送窗口内的4号数据报文段发送出去，接收方收到后，发现这不是按序到达的报文段，因此给发送方发回，针对2号报文段的重复确认，表明我现在希望收到的是三号报文段，但是我没有收到三号报文段，而是收到了未按序到达的报文段，
- 发送方还可以将发送窗口内的5号数据报文段发送出去，接收方收到后发现这不是按序到达的报文段，因此给发送方发回针对2号报文段的重复确认，
- 发送方还可以将发送窗口内的6号数据报文段发送出去，接收方收到后发现这不是按需到达的报文段，因此给发送方发回针对2号报文段的重复确认，至此发送方会收到三个连续的对二号报文段的重复确认，就要立即重传三号报文段，
- 接收方收到后给发送方发回针对6号报文段的确认，表明序号到六为止的报文段都正确接收了，这样就不会造成对三号报文段的超时重传，而是提早进行了重传。

![image-20230328000033264](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328000033264.png)

![image-20230328000148676](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328000148676.png)

习题：

![image-20230328000252957](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328000252957.png)
超时就是代表拥塞，需要重新回到慢开始；快重传是指未超时时收到三个重复确认。当第四个RTT得到应答“后”，拥塞窗口就变成9了。



## 5.6TCP超时重传时间的选择

![image-20230328001038532](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328001038532.png)

![image-20230328001103970](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328001103970.png)
综合上述两种情况，我们可以得出这样的结论，超时重传时间RTO的值应该设置为略大于报文段往返时间RTT的值。

![image-20230328001220990](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328001220990.png)

例如现在主机A给主机B发送TCP数据报文段一，主机B收到后，给主机A发送相应的确认报文段，主机A这次测得的报文段往返时间RTT一如图所示，显然RTT1远大于RTT0，如果超时重装时间RTO还是我们之前所确定的略大于RTT0的话，这对于数据报文段1是不合适的，会造成该报文段不必要的重传。

![image-20230328001339019](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328001339019.png)

![image-20230328001418816](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328001418816.png)

往返时间RTT的测量比较复杂：

![image-20230328001453930](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328001453930.png)

![image-20230328001554119](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328001554119.png)

![image-20230328001623277](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328001623277.png)

<img src="C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328001645031.png" alt="image-20230328001645031" style="zoom: 50%;" />

小结：

![image-20230328001744238](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328001744238.png)

## 5.7TCP可靠传输的实现

为了简单起见，我们假定网络不存在拥塞问题，也就是发送方在构造自己的发送窗口时，仅考虑接收方的接收窗口，而**不考虑拥塞窗口**。由于本例中接收方告诉发送方自己的接收窗口尺寸为20，因此发送方将自己的发送窗口尺寸也设置为20，发送方在没有收到接收方确认的情况下，可以把发送窗口内的数据依次全部发送出去，**凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。**这是发送窗口的后沿，这是发送窗口的前沿，发送窗口后沿的后面部分是已发送并已收到确认的数据字节的序号，这些数据字节显然不需要再保存在发送缓存中了，可以将它们删除。

![image-20230328002022699](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328002022699.png)

![image-20230328002057141](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328002057141.png)

![image-20230328002537140](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328002537140.png)

我们再来看看接收方的接收窗口，它的尺寸为20，在接收窗口外面到30号为止的数据是已经发送过相应确认，并已交付给应用进程的数据，因此无需再保留这些数据，可将他们从接收缓存中删除了。接收窗口内31~50号数据是允许接收的数据，接收窗口外51号及其后续数据目前不允许接收。假设发送方之前发送的封装有32和33号数据的报文段到达了接收方，由于数据序号落在接收窗口内，所以接收方接受他们，并将他们存入接收缓存，但是他们是未按序到达的数据，因为31号数据还没有到达，这有可能是丢了，也有可能是滞留在网络中的某处。请注意接收方只能对按序收到的数据中的最高序号给出确认，因此接收方发出的确认报文段中的确认序号仍然是31，也就是希望收到31号数据，窗口字段的值仍是20，表明接收方没有改变自己接收窗口的大小，发送方收到该确认报文段后，发现这是一个针对31号数据的重复确认，就知道接收方收到了未按序到达的数据，由于这是针对31号数据的第一个重复确认因此，这并不会引起发送方针对该数据的快重传。另外接收方通知的窗口尺寸仍是20，因此发送方保持自己的发送窗口尺寸为20，现在假设封装有31号数据的报文段到达了接收方，方接受该报文段，将其封装的31号数据存入接收缓存，接收方现在可将接收到的31~33号数据交付给应用进程。

然后将接收窗口向前移动三个序号，并给发送方发送确认报文段。该确认报文段中窗口字段的值仍为20，表明接收方没有改变自己接收窗口的大小，确认号字段的值为34，这表明接收方已经收到了序号33为止的全部数据。

![image-20230328002651012](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328002651012.png)

现在假设又有几个数据，报文段到达了接收方，他们封装有37 38以及40号数据，这些数据的序号虽然落在接收窗口内，但他们都是未按需到达的数据，只能先暂存在接收缓存中。假设接收方先前发送的确认报文段到达了发送方，发送方接收后，将发送窗口向前滑动三个序号，发送窗口的尺寸保持不变，这样就有新序号51~53落入发送窗口内，而序号31~33移出了发送窗口，现在可将31~33号数据从发送缓存中删除了，因为已经收到了接收方针对他们的确认

![image-20230328002714633](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328002714633.png)

发送方继续将发送窗口内，序号42~53的数据封装在几个不同的报文段中发送出去，现在发送窗口内的序号已经用完了，发送方在未收到接收方发来确认的情况下，不能再发送新的数据，序号落在发送窗口内的已发送数据，如果迟迟收不到接收方的确认，则会产生超时重传。

![image-20230328002754721](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328002754721.png)

习题：

![image-20230328002853442](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328002853442.png)这是主机甲给主机乙发送的第一个数据报文段，其首部中序号字段的值为200，也就是说其数据载荷的第一个字节的序号为200，由于数据载荷共有300个字节，因此数据载荷的最后一个字节的序号为499，

这是主机甲给主机乙发送的第二个数据报文段的数据载荷部分。由于前一个报文段数据载荷的最后一个字节的序号是499，因此本报文段数据载荷的第一个字节的序号应为500，相应的写首部中序号字段的值应为500，由于数据载荷共有500个字节，因此数据载荷的最后一个字节的序号为999，

这是主机乙给主机甲发送的确认报文段的首部，其中确认序号字段的值为1000，这是因为主机已目前已经按序正确接收了序号到999为止的全部数据，现在希望接收序号为1000及其后续的数据，该确认报文段实际上是对已正确接收的两个TCP数据报文段的累计确认。

![image-20230328003034458](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328003034458.png)
由于TCP规定只能对按序到达的最高序号进行确认，因此主机乙发送到确认报文段，实际上是对第一个数据报文段的确认。

小结：

![image-20230328003115337](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328003115337.png)

## 5.8TCP的运输连接管理

![image-20230328003144778](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328003144778.png)

![image-20230328003209710](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328003209710.png)

接下来我们就来看看TCP使用三报文握手建立连接的具体过程。这是两台要基于TCP进行通信的主机，其中一台主机中的某个应用进程，主动发起TCP连接，建立称为TCP客户。另一台主机装被动等待TCP连接建立的应用进程，称为TCP服务器。我们可以将TCP建立连接的过程比喻为握手，握手需要在TCP客户和服务器之间交换三个TCP报文段

最初两端的TCP进程都处于关闭状态，一开始 TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息，例如 TCP连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前发送和接收序号等。之后就要准备接受TCP客户进程的连接请求。此时TCP服务器进程就要进入监听状态，等待TCP客户进程的连接请求。TCP服务器进程是被动等待来自TCP客户进程的连接请求，而不是主动发起，因此称为被动打开连接。

- TCP客户进程也是首先创建传输控制块，然后在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态。TCP连接请求报文段首部中的同步位SYN被设置为1，表明这是一个**TCP连接请求报文段**，序号字段SEQ被设置了一个初始值X，作为TCP客户进程所选择的初始序号。请注意TCP规定，SYN被设置为1的报文段，不能携带数据，但要消耗掉一个序号。由于TCP连接建立是由TCP客户进程主动发起的，因此称为主动打开连接。
- TCP服务器进程收到TCP连接请求报文段后。如果同意建立连接，则向TCP客户进程发送**TCP连接请求确认报文段**，并进入同步已接收状态。该报文段首部中的同部位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段。序号字段SEQ被设置了一个初始值Y，作为TCP服务器进程所选择的初始序号，确认号字段ACK的值被设置成了X+1，这是对TCP客户进程所选择的初始序号的确认。请注意这报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号
- TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的**TCP确认报文段**，并进入连接已建立状态。该报文段首部中的确认为ACK被设置为1，表明这是一个普通的TCP确认报文段，序号字段SEQ被设置为X+1，这是因为 TCP客户进程发送的第一个TCP报文段的序号为X并且不携带数据，因此第二个报文段的序号为X+1。请注意TCP规定，普通的TCP确认报文段可以携带数据，但如果不携带数据则不消耗序号。在这种情况下，所发送的下一个数据报文段的序号仍是X+1，确认号字段ACK被设置为Y+1，这是对TCP服务器进程所选择的初始序号的确认。

TCP服务器进程收到该确认报文段后也进入连接已建立状态。现在TCP双方都进入了连接已建立状态，他们可以基于已建立好的TCP连接进行可靠的数据传输了。

![image-20230328003748558](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328003748558.png)

请同学们思考这样一个问题，为什么TCP客户进程最后还要发送一个普通的TCP确认报文段，这是否多余？换句话说，能否使用两报文握手建立连接答案是并不多余，不能简化为两报文握手。我们来举例说明，考虑这样一种情况，TCP客户进程发出一个TCP连接请求报文段，但该报文段在某些网络节点长时间滞留了，这必然会造成该报文段的超时重传。假设重传的报文段在TCP服务器进程正常接收，TCP服务器进程给TCP客户进程发送一个TCP连接，请求确认报文段，并进入连接已建立状态。请注意，由于我们改为两报文握手，因此TCP服务器进程发送完TCP连接请求确认报文段后进入的是连接已建立状态，而不像三报文握手那样进入同步已接收状态，并等待TCP客户进程发来，针对TCP连接请求确认报文段的普通确认报文段，TCP客户进程收到TCP连接，请求确认报文段后，进入TCP连接已建立状态，但不会给TCP服务器进程发送针对该报文段的普通确认报文段，现在 TCP双方都处于连接已建立状态，他们可以相互传输数据之后可以通过四报文挥手来释放连接，TCP双方都进入了关闭状态，

一段时间后之前滞留在网络中的失效的TCP连接请求报文段到达了TCP服务器进程，TCP服务器进程会误认为这是TCP客户进程，又发起了一个新的TCP连接请求，于是给TCP客户进程发送TCP连接请求，确认报文段，并进入连接已建立状态。该报文段到达TCP客户进程，由于TCP客户进程并没有发起新的TCP连接请求，并且处于关闭状态，因此不会理会该报文段，但TCP服务器进程已进入了连接已建立状态，他认为新的TCP连接已建立好了，并一直等待TCP客户进程发来数据，这将白白浪费TCP服务器进程所在主机的很多资源。

<img src="C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328003722336.png" alt="image-20230328003722336" style="zoom:50%;" />

习题：

![image-20230328003849855](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328003849855.png)

小结：

![image-20230328003901529](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328003901529.png)

## 5.8.2 TCP的连接释放

举例说明，数据传输结束后，TCP通信双方都可以释放连接，现在TCP客户进程和TCP服务器进程都处于连接已建立状态。假设使用TCP客户进程的应用进程，通知其主动关闭TCP连接，TCP客户进程会发送TCP连接释放报文段，并进入终止等待一状态。该报文段首部中的终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认。序号seq字段的值设置为u它**等于TCP客户进程之前已传送过的数据的最后一个字节的序号加一。**
请注意TCP规定终止为FIN等于一的报文段，即使不携带数据也要消耗掉一个序号，**确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的数据的最后一个字节的序号加一**。
TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段，并进入关闭等待状态。该报文段首部中的确认为ACK的值，被设置为一，表明这是一个普通的TCP确认报文段，序号seq字段的值设置为v，它等于TCP服务器进程之前以传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配，确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认。

TCP服务器进程这时应通知高层应用进程，TCP客户进程要断开与自己的TCP连接，**此时从TCP客户进程到TCP服务器进程，这个方向的连接就释放了**，这时的TCP连接属于半关闭状态，也就是TCP客户进程**已经没有数据要发送**了，但TCP服务器进程如果还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程，这个方向的连接并未关闭，这个状态可能会持续一段时间，TCP客户进程收到TCP确认报文段后，就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段。

若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就要通知其TCP服务器进程释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接，TCP服务器进程发送TCP连接释放报文段，并进入最后确认状态。该报文段首部中的终止为FIN和确认为ACK的值，都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认。现在假定序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送了一些数据，确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。

TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态，该报文段首部中的确认为ACK的值，被设置为1，表明这是一个普通的TCP确认报文段，序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段，虽然不携带数据，但要消耗掉一个序号，确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。

![image-20230328004818381](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328004818381.png)

 TCP客户进程在发送完最后一个确认报文段后，为什么不直接进入关闭状态，而是要进入时间等待状态，两倍MSL后才进入关闭状态，这是否有必要呢？来看这种情况，TCP服务器进程发送TCP连接释放报文段后进入最后确认状态，TCP客户进程收到该报文段后，发送普通的TCP确认报文段，并进入关闭状态，而不是时间等待状态。然而该TCP确认报文段丢失了，这必然会造成TCP服务器进程，对之前所发送的TCP连接释放报文段的超时重传，并仍处于最后确认状态。重传的TCP连接释放报文段到达TCP客户进程，由于TCP客户进程属于关闭状态，因此不理睬该报文段，这必然会造成 TCP服务器进程反复重传TCP连接释放报文段，并一直处于最后确认状态，而无法进入关闭状态。

因此时间等待状态以及处于该状态两倍MSL的时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。另外TCP客户进程在发送完最后一个TCP确认报文段后，再经过两倍MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中不会出现旧连接中的报文段。以上就是TCP通过4报文挥手释放连接的过程。

![image-20230328004904485](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328004904485.png)

TCP中饱和计时器的作用。设想这样一种情况，TCP双方已经建立了连接，后来TCP客户进程所在的主机突然出现了故障，显然 TCP服务器进程以后就不能再收到TCP客户进程发来的数据，因此应当有措施使TCP服务器进程，不要再白白等待下去。换句话说，TCP服务器进程应该如何发现这种情况？

![image-20230328005043925](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328005043925.png)

小结：

![image-20230328003928419](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328003928419.png)

## 5.9 TCP报文段的首部格式

![image-20230328005151129](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328005151129.png)

TCP报文段的首部格式与IP数据报的首部格式类似，都是由二十字节的固定首部和最大四十字节的扩展首部构成。
![image-20230328005236708](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328005236708.png)

<img src="C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328005339314.png" alt="image-20230328005339314" style="zoom: 50%;" />

![image-20230328005716367](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328005716367.png)

![image-20230328005758696](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328005758696.png)

<img src="C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328005807654.png" alt="image-20230328005807654" style="zoom:60%;" />

我们来举例说明这三个字段的作用。TCP客户进程发送一个TCP报文段，该报文段首部中序号字段的取值为201，这表示该TCP报文段数据载荷的第一个字节的序号为201，假设数据载荷的长度为100字节，首部中确认号字段的取值为800，这表示TCP客户进程收到了TCP服务器进程发来的序号到799为止的全部数据，现在期望收到序号从800开始的数据，为了使确认号字段有效，首部中的确认标志位ACK的值必须设置为1。
TCP服务器进程收到该报文段后，也给TCP客户进程发送TCP报文段，该报文段首部装序号字段的取值为800，这表示该TCP报文段数据载荷的第一个字节的序号为800，这正好与TCP客户进程的确认相匹配，假设数据载荷的长度为200字节，首部中确认号字段的取值为301，这表示TCP服务器进程收到了TCP客户进程发来的序号到300为止的全部数据，现在期望收到序号从301开始的数据，为了使确认号字段有效，首部中的确认标志为ACK的值必须设置唯一。

![image-20230328005935141](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328005935141.png)

![image-20230328005951404](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328005951404.png)

![image-20230328010247661](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010247661.png)

我们来举例说明，假设这个TCP报文段首部中的数据偏移字段的取值为二进制的0101，那么首部长度就为20字节，因为二进制的0101的10进制值是5，而该字段以四字节为单位，因此5×4字节=20字节。假设这个TC报文段首部中的数据偏移字段的取值为二进制的1111，那么首部长度就为60字节，因为二进制1111的10进制值为15，而该字段以四字节为单位，因此15×4字节等于60字节。
![image-20230328010335919](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010335919.png)

![image-20230328010408223](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010408223.png)
流量控制，需要注意的是发送窗口的大小还取决于拥塞窗口的大小，也就是应该从接收窗口和拥塞窗口中取小者。

![image-20230328010420975](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010420975.png)
具体的校验算法就不再赘述了，因为它仅仅是一种检测算法，与TCP的其他重要功能相比，检错算法并不是重点。

![image-20230328010533154](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010533154.png)

![image-20230328010603615](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010603615.png)

![image-20230328010614538](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010614538.png)

![image-20230328010633810](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010633810.png)

![image-20230328010659041](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010659041.png)
接收方收到紧急标志为1的报文段，会按照紧急指针字段的值，从报文端数据载荷部分取出紧急数据，并直接上交应用进程，而不必在接收缓存中排队。

TCP报文段首部除了24节的固定部分，还有最大40节的选项部分，增加选项可以增加TCP的功能。目前有以下选项，

![image-20230328010808043](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010808043.png)

![image-20230328010816948](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010816948.png)

小结：

![image-20230328010905853](C:\Users\melody\AppData\Roaming\Typora\typora-user-images\image-20230328010905853.png)

















